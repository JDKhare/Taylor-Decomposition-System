/*
 * =====================================================================================
 *
 *        Filename:  TedManWriteTed.cc
 *     Description:
 *         Created:  08/01/2009 07:14:00 PM EST
 *          Author:  Daniel F. Gomez-Prado
 *         Company:
 *
 * =====================================================================================
 *  $Revision:: 204                                          $: Revision of last commit
 *  $Author:: daniel@linux                                   $: Author of last commit
 *  $Date:: 2010-11-18 08:13:53 -0500(Thu, 18 Nov 2010)$: Date of last commit
 * =====================================================================================
 */

#include <cstdlib>
#include <string>
#include <cstdio>
#include <iostream>
#include <sstream>
#include <fstream>
#include <cassert>
#include <algorithm>
#include <list>
#include <cstring>

#include "TedMan.h"
#include "TedNode.h"
#include "TedKids.h"
#include "TedVar.h"
#include "ETedNode.h"

#include "poly.h"
using namespace polyparser;

#include "util.h"
using util::Util;

#include "Environment.h"
using namespace tds;

#ifdef _MSC_VER
# pragma warning(disable:4996)
#endif

namespace ted {
	//#define _DEBUG_TEDREAD on
	//#undef _DEBUG_TEDREAD

	string TedMan::write(const TedNode* pNode) {
		ostringstream oss;
		unsigned int index=0;
		TedNode* pKid=NULL;
		int weight=0;
		int regs = 0;
		oss << "# node " << pNode->getName()<< " with " << pNode->numKids()<< " children" << endl;
		oss << pNode->numKids()<< " " << pNode->getName()<< " " << obfuscate(pNode)<< endl;
		FOREACH_KID_OF_NODE(pNode) {
			index = _iterkids.getIndex();
			pKid = _iterkids.Node<TedNode>();
			weight = _iterkids.getWeight();
			regs = _iterkids.getRegister();
			oss << index << " " << weight << " " << obfuscate(pKid) << " " << regs << endl;
		}
		return oss.str();
	}

	/** Records the Teds existing in the Ted Manager*/
	void TedMan::write(string filename) {
		ofstream ofile;
		if(filename.empty()) {
			//TODO probable leak as tempFileName allocates memory
			filename = Util::tempFileName(Environment::getStr("show_directory").c_str(), "saved_", "ted");
		}
		if(!filename.empty())
			ofile.open(filename.c_str());
		if(!ofile.is_open()) {
			throw(string("04020. Cannot open temporary file for writing."));
			return;
		}
		ofile << "#######################################" << endl;
		ofile << "# File generated by TDS.              #" << endl;
		ofile << "# http://incascout.ecs.umass.edu/main #" << endl;
		ofile << "#######################################" << endl;
		ofile << "# To load this file back, type:" << endl;
		ofile << "# Tds 01> read \"filename\"" << endl;
		ofile << endl;
		ofile << "##########################" << endl;
		ofile << "# total number of nodes" << endl;
		ofile << _container.nodeCount()<< endl;
		ofile << "##########################" << endl;
		ofile << "# node ONE identifier" << endl;
		ofile << obfuscate(TedNode::getOne())<< endl;
		ofile << "##########################" << endl;
		ofile << "# variable order: top to bottom" << endl;
		TedContainerOrder tnodesOrdered = _container.order();
		for(TedContainerOrder::const_iterator it = tnodesOrdered.begin(); it!= tnodesOrdered.end(); it++) {
			ofile << it->second.first->getName();
			if (it->second.first->isBinary()) {
				ofile << ": ";
			} else {
				ofile << " ";
			}
		}
		ofile << endl;
		ofile << "##########################" << endl;
		ofile << "# node listing: bottom to top" <<endl;
		ofile << "# - number of children, variable name, ID" << endl;
		ofile << "# - child  weight ID registers" << endl;
		ofile << "# WARNING:" << endl;
		ofile << "# If the node listing does not respect the bottom to top ordering" << endl;
		ofile << "# error 04036 will occur and the reading will be aborted" << endl;
#if 0
		for(TedContainerOrder::reverse_iterator it = tnodesOrdered.rbegin(); it != tnodesOrdered.rend(); it++) {
			for(TedSet::iterator jt = it->second.second->begin(); jt != it->second.second->end(); jt++) {
				ofile << write(*jt);
			}
		}
#else
		TedRetiming retime(this);
		for(TedContainerOrder::reverse_iterator it = tnodesOrdered.rbegin(); it != tnodesOrdered.rend(); it++) {
			const TedVar& var = *it->second.first;
			list<TedNode*> preorder = retime.order_retimed_same_var_set(var);
			for(list<TedNode*>::reverse_iterator jt = preorder.rbegin(); jt != preorder.rend(); jt++) {
				ofile << write(*jt);
			}
		}
#endif
		ofile << "##########################" << endl;
		ofile << "# PO list:" << endl;
		ofile << "# - output name, ID, weight, register" << endl;
		for(PrimaryOutputs::iterator p = _pos.begin(); p != _pos.end(); p++) {
			ofile << p->first << " " << obfuscate(p->second.Node())<< " ";
			ofile << p->second.getWeight() << " " <<  p->second.getRegister() << endl;
		}
		ofile << "##########################" << endl;
		ofile << "#EOF" << endl;
		ofile.close();
	}

	void TedMan::read(string filename) {
		assert(!filename.empty());
		ifstream in;
		in.open(filename.c_str());
		if(!in) {
			throw(string("04021. ")+ filename+string(" doesn't exist"));
			return;
		}
		char buf[65535];
		char* ptr = buf;
		string nodeName;
		string nodeID;
		string kidID;
		string poName;
		string poID;
		int numberNodes = 0;
		int numberKids = 0;
		int weightKid = 0;
		int numKid = 0;
		int poWeight = 0;
		int poRegister = 0;
		int regInt = 0;
		int regKid = 0;
		char* tok;
		TedNode* pNode = NULL;
		TedNode* pNodeTo = NULL;
		//TedNode* pLeak = NULL;
		typedef map<string, TedNode*> TedMap;
		TedMap uniqueTable;
		TedMap::iterator uniqueIterator;
		//char outputBuf[20];
		int outputCounter = 0;
		//TedMap actualTable = TedNode::getPOTable();
		enum switchcase {node_count, node_one, variable_order, node_list, kid_list, po_list};
		int toParse = node_count;
		while(in.getline(buf, 65535)) {
#if defined(_DEBUG_TEDREAD)
			cout << "line is: " << buf << endl;
#endif
			if(strlen(ptr)>0 & ptr[strlen(ptr)-1]=='\r') {
				ptr[strlen(ptr)-1]='\0';
			}
			if(*ptr  == '#' || *ptr == '\n' || *ptr == '\0') {
				continue;
			}
			switch(toParse) {
			case node_count:
				{
					//read the number of nodes to be loaded
					tok = strtok(ptr, " ");
					numberNodes = atoi(tok);
#if defined(_DEBUG_TEDREAD)
					cout << "number of nodes = " << numberNodes << endl;
#endif
					toParse++;
					break;
				}
			case node_one:
				{
					//read the ID of node ONE
					tok = strtok(ptr, " ");
					uniqueTable.insert(pair<string, TedNode*>(string(tok), TedNode::getOne()));
					toParse++;
					break;
				}
			case variable_order:
				{
					tok=strtok(ptr, " ");
					while(tok != '\0') {
						string varName(tok);
						bool is_binary = false;
						int last = strlen(varName.c_str());
						if ( varName[last-1]==PolyParser::BIN) {
							is_binary = true;
							varName.erase(last-1);
						}
						size_t found = varName.find('@');
						if(string::npos==found) {
							registerVar(varName,is_binary);
						} else {
							string varname = varName.substr(0, found);
							string regVal = varName.substr(found+1);
							std::pair<bool, long> tt = Util::atoi(regVal.c_str());
							if(tt.first) {
								int val = (int)tt.second;
								last = strlen(varName.c_str());
								if ( varName[last-1]==PolyParser::BIN) {
									is_binary = true;
									varName.erase(last-1);
								}
								const TedVar* currentVar = TedVarMan::instance().createVar(varname,is_binary);
								assert(NULL == currentVar->getBase());
								TedVar* newVar = TedVarMan::instance().createRetimedVar(*currentVar, val);
								_container.registerVar(*newVar);
								//_container.registerRetimedVarAt(*newVar,*currentVar);
							} else {
								assert(false);
							}
						}
						tok = strtok(NULL, " ");
					}
					//todo:
					//compare that variable order of current TED and the one being loaded are compatible
					toParse++;
					break;
				}
			case node_list:
				{
					//read number of kids
					tok = strtok(ptr, " ");
					numberKids = atoi(tok);
					//read variable name
					tok = strtok(NULL, " ");
					nodeName = string(tok);
					//read unique ID
					tok = strtok(NULL, " ");
					nodeID = string(tok);
					size_t found = nodeName.find('@');
					regInt = 0;
					if(string::npos!=found) {
						string regVal = nodeName.substr(found+1);
						std::pair<bool, long> tt = Util::atoi(regVal.c_str());
						if(tt.first) {
							regInt = (int) tt.second;
						}
					}
#if defined(_DEBUG_TEDREAD)
					cerr << " nodename=" << nodeName << endl;
					cerr << " with nodeId=" << nodeID << endl;
#endif
					toParse++;
					int last = strlen(nodeName.c_str());
					bool is_binary = false;
					if(nodeName[last-1]==PolyParser::BIN) {
						nodeName.erase(last-1);
						is_binary = true;
					}
					const TedVar* var = TedVarMan::instance().createVar(nodeName,is_binary);
					assert(var);
					TedKids kid;
					kid.insert(1, TedNode::getOne(), 1, TedRegister(0));
					pNode = new ETedNode(*var, kid, var->getRegister());
					pNode->removeKid(1);
#if defined(_DEBUG_TEDREAD)
					cerr << " nodename=" << nodeName << endl;
					cerr << " with nodeId=" << nodeID << endl;
#endif
					break;
				}
			case kid_list:
				{
					numberKids--;
					//read kid number "i"
					tok = strtok(ptr, " ");
					string strNumKid(tok);
					numKid = atoi(tok);
					//read weight
					tok = strtok(NULL, " ");
					weightKid = atoi(tok);
					//read kid node ID
					tok = strtok(NULL, " ");
					kidID = string(tok);
					tok = strtok(NULL, " ");
					if (tok) {
						regKid = atoi(tok);
					} else {
						regKid = 0;
					}
					uniqueIterator = uniqueTable.find(kidID);
					if(uniqueIterator != uniqueTable.end()) {
						pNodeTo = uniqueIterator->second;
						pNode->addKid(numKid, pNodeTo, weightKid,regKid);
					} else {
#if defined(_DEBUG_TEDREAD)
						cerr << " error at nodename=" << nodeName << endl;
						cerr << " with nodeId=" << nodeID << endl;
						cerr << " its child=" << strNumKid << endl;
						cerr << " pointing to=" <<  kidID << endl;
						cerr <<  " was not found" << endl;
#endif
						string error = "04036. While processing node ";
						error += nodeName;
						error += " ";
						error += nodeID;
						error += "\n";
						error += "Its child node ";
						error += strNumKid;
						error += " pointing to ";
						error += kidID;
						error += " was not found";
						throw(error);
					}
					if(0==numberKids) {
						numberNodes--;
						TedNode* node = _container.getNode(*pNode->getVar(),*pNode->getKids(), regInt);
						delete pNode;
						uniqueTable.insert(pair<string, TedNode*>(nodeID, node));
						if(numberNodes > 0) {
							//parse more nodes
							toParse--;
						} else {
							//start reading the POs
							toParse++;
						}
					}
					break;
				}
			case po_list:
				{
					/*read the output name*/
					tok = strtok(ptr, " ");
					poName = string(tok);
					/*read the ID*/
					tok = strtok(NULL, " ");
					poID = string(tok);
					/*read the weight*/
					tok = strtok(NULL, " ");
					poWeight = atoi(tok);
					tok = strtok(NULL, " ");
					if (tok) {
						poRegister = atoi(tok);
					} else {
						poRegister = 0;
					}
					uniqueIterator = uniqueTable.find(poID);
					if(uniqueIterator != uniqueTable.end()) {
						pNode = uniqueIterator->second;
						outputCounter++;
						TedNodeRoot po(pNode, poWeight);
						po.setRegister(poRegister);
						PrimaryOutputs::iterator it = _pos.find(poName);
						if(it == _pos.end()) {
							//reload PO
							_pos[poName] = po;
						} else {
							//if PO already exist load it as PO_read
							//and generate its difference PO_diff = PO - PO_read
							po.setType((*it).second.getType());
							string poName2cmp = poName+"_read";
							_pos[poName2cmp] = po;
							registerVar(poName);
							registerVar(poName2cmp);
							//TedNode* pNodeInit = getNode(poName);
							TedNode* pNode2cmp = getNode(poName2cmp);
							TedNode* pNodeIni = new ETedNode(poName);
							TedKids newKids;
							newKids.insert(1, TedNode::getOne(), 1, TedRegister(0));
							newKids.insert(0, pNode2cmp, -1, TedRegister(0));
							pNodeIni->setKids(newKids);
							//pNodeIni->addKid(0, pNode2cmp, -1);
							TedNode* pNodeInis = _container.getNode(*pNodeIni->getVar(),*pNodeIni->getKids());
							if (pNodeIni==pNodeInis) {
								delete pNodeIni;
							}
							string poNameDiff = poName+"_diff";
							TedNodeRoot poDiff(pNodeInis, 1);
							_pos[poNameDiff] = poDiff;
							//registerVar(poNameDiff);
							if(_pos[poName].Node()!= _pos[poName2cmp].Node()) {
								cerr << "Two different functions have the same name" << endl;
								cerr << "Output " << poName << " != " << poName2cmp << endl;
							}
						}
					} else {
						throw(string("04022. While linking output node ")+ poName);
					}
					break;
				}
			default:
				throw(string("04023. While retrieving the TDS data structure"));
				break;
			}
		}
	}

}
