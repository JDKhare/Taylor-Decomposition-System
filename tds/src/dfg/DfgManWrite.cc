/* =====================================================================================
 *
 *       Filename:  DfgManWrite.cc
 *    Description:
 *        Created:  04/04/2009 02:26:37 PM
 *         Author:  Daniel f. Gomez-Prado(dgomezpr), dgomezpr@ecs.umass.edu
 *        Company:  UMASS
 *
 * =====================================================================================
 *  $Revision:: 206                                          $: Revision of last commit
 *  $Author:: daniel@win                                     $: Author of last commit
 *  $Date:: 2010-11-18 08:13:53 -0500(Thu, 18 Nov 2010)$: Date of last commit
 * =====================================================================================
 */



#include <cstdlib>
#include <string>
#include <cstdio>
#include <iostream>
#include <sstream>
#include <fstream>
#include <cassert>
#include <algorithm>
#include <list>
#include <cstring>

#include "DfgMan.h"
#include "DfgNode.h"
#include "DfgOperator.h"


#include "util.h"
using util::Util;

#include "Environment.h"
using tds::Environment;

#ifdef _MSC_VER
# pragma warning(disable:4996)
#endif

#include "Bitwidth.h"
using namespace data;

#include "TedVar.h"
#include "TedVarMan.h"
using namespace ted;

namespace dfg {
#define GAPPA_COMPUTATION(node,type)\
	switch(vNodes[i]->node()->getOp()) { \
	case DfgOperator::ADD: \
	case DfgOperator::SUB: \
	case DfgOperator::MUL: \
	case DfgOperator::DIV: \
	case DfgOperator::LSH: \
	case DfgOperator::RSH: \
						   ofile << #type << opTable[vNodes[i]->node()->getOp()] << gappaTerm[vNodes[i]->node()]; \
		/* ofile << #type << opTable[vNodes[i]->node()->getOp()] << vNodes[i]->node()->_op->getID();*/ \
		break; \
	case DfgOperator::VAR: \
						   ofile << #type << vNodes[i]->node()->getName(); \
		break; \
	case DfgOperator::VARCONST: \
								{ \
									TedVar* pvar = vNodes[i]->node()->getTedVarIfExist(); \
									if(!pvar || !pvar->hasRange())\
									throw(string("01028. No associated TED variable with DFG node")); \
									string range = pvar->getRange(); \
									ofile << range; \
									break; \
								} \
	case DfgOperator::CONST: \
							 assert(vNodes[i]->node()->isConst()); \
		ofile << vNodes[i]->node()->getConst(); \
		break; \
	default: \
			 throw(string("01025. UNKOWN DFG node type.")); \
	}

	string DfgMan::write(DfgNode* pNode) {
		ostringstream oss;
		oss << "# node " << pNode << " with ID=" << pNode->getOperator()->getID() << endl;
		switch(pNode->getOp()) {
		case DfgOperator::ADD: oss << "ADD " << pNode->getOpStr()<< " " << pNode->getOperator()->getID(); break;
		case DfgOperator::MUL: oss << "MUL " << pNode->getOpStr()<< " " << pNode->getOperator()->getID(); break;
		case DfgOperator::SUB: oss << "SUB " << pNode->getOpStr()<< " " << pNode->getOperator()->getID(); break;
		case DfgOperator::LSH: oss << "LSH " << pNode->getOpStr()<< " " << pNode->getOperator()->getID(); break;
		case DfgOperator::RSH: oss << "RSH " << pNode->getOpStr()<< " " << pNode->getOperator()->getID(); break;
		case DfgOperator::REG: oss << "REG " << pNode->getOpStr()<< " " << pNode->getOperator()->getID(); break;
		case DfgOperator::VARCONST:
							   //TODO: At the moment VARCONST is saved as VAR
		case DfgOperator::VAR: oss << "VAR " << pNode->getName()<< " " << pNode->getOperator()->getID(); break;
		case DfgOperator::CONST: oss << "CONST " << pNode->getConst()<< " " << pNode->getOperator()->getID(); break;
		default:
								 oss << "ERR 0 NULL"; break;
		}
		return oss.str();
	}

	/** Records the Dfgs existing in the Dfg Manager*/
	void DfgMan::write(string filename) {
		ofstream ofile;
		if(filename.empty()) {
			//TODO probable leak as tempFileName allocates memory
			filename = Util::tempFileName(Environment::getStr("show_directory").c_str(), "saved_", "dfg");
		}
		if(!filename.empty())
			ofile.open(filename.c_str());
		if(!ofile.is_open()) {
			throw(string("01002. Cannot open temporary file for writing."));
			return;
		}
		ofile << "#######################################" << endl;
		ofile << "# File generated by TDS.              #" << endl;
		ofile << "# http://incascout.ecs.umass.edu/main #" << endl;
		ofile << "#######################################" << endl;
		ofile << "# To load this file back, type:" << endl;
		ofile << "# Tds 01> read \"filename\"" << endl;
		ofile << endl;
		vector <DfgNode* > vNodes;
		int maxLevel = collectDFS(vNodes);
		ofile << "##########################" << endl;
		ofile << "# maximum number of levels" << endl;
		ofile << maxLevel << endl;
		ofile << "##########################" << endl;
		ofile << "# total number of nodes" << endl;
		ofile << vNodes.size()<< endl;
		ofile << "##########################" << endl;
		ofile << "# operand delay in DFG" << endl;
		ofile << "# ADD SUB MUL LSH REG" << endl;
		ofile << DfgNode::_addDelay << " " << DfgNode::_subDelay << " ";
		ofile << DfgNode::_mpyDelay << " " << DfgNode::_lshDelay << " ";
		ofile << DfgNode::_regDelay << endl;
		ofile << "##########################" << endl;
		ofile << "# node listing: PI - PO" <<endl;
		ofile << "# - type op, node name, ID" << endl;
		ofile << "# - left child ID" << endl;
		ofile << "# - right child ID" << endl;
		//not the optimal implementation, but it gets the job done
		for(unsigned int i = 0; i <= maxLevel; i ++) {
			for(unsigned int j = 0; j < vNodes.size(); j ++)if(vNodes[j]->getLevel() ==i) {
				ofile << write(vNodes[j])<< endl;
				if(vNodes[j]->isOp()) {
#if 0
					ofile << vNodes[j]->getLeft()<<endl;
					ofile << vNodes[j]->getRight()<<endl;
#else
					ofile << vNodes[j]->getLeft()->getOperator()->getID() << endl;
					ofile << vNodes[j]->getRight()->getOperator()->getID() << endl;
#endif
				}
			}
		}
		ofile << "##########################" << endl;
		ofile << "# PO list:" << endl;
		ofile << "# - PO name, ID" << endl;
		for(map<string, DfgNode*>::iterator p = _mPos.begin(); p != _mPos.end(); p++) {
			ofile << p->first << " " << (p->second)->getOperator()->getID() << endl;
		}
		ofile << "##########################" << endl;
		ofile << "#EOF" << endl;
		ofile.close();
	}

	void DfgMan::read(string filename) {
		assert(!filename.empty());
		ifstream in;
		in.open(filename.c_str());
		if(!in) {
			throw(string("01003. ")+filename+string(" doesn't exist"));
			return;
		}
		/*if(!_mPos.empty()) {
		  throw(string("01004. A DFG already exist. Purge it, before loading another one"));
		  return;
		  }*/
		char buf[65535];
		char* ptr = buf;
		string nodeName;
		string nodeTypeStr;
		string nodeID;
		string leftID;
		string rightID;
		string poName;
		string poID;
		DfgOperator::Type nodeType;
		int nodeCount = 0;
		int numberNodes = 0;
		int maxLevel = 0;
		char* tok;
		DfgNode* pNode = NULL;
		DfgNode* pLeft = NULL;
		DfgNode* pRight = NULL;
		typedef map<string, DfgNode*> DfgMap;
		DfgMap uniqueTable;
		DfgMap::iterator uniqueIterator;
		//int outputCounter = 0;
		enum switchcase {dfg_max, dfg_count, op_delay, node_list, left_kid, right_kid, po_list};
		int toParse = dfg_max;
		pair<bool,wedge> retimeValue;
		while(in.getline(buf, 65535)) {
			//cout << "line is: " << buf << endl;
			if(*ptr  == '#' ||*ptr == '\n' ||*ptr == '\0') {
				continue;
			}
			switch(toParse) {
			case dfg_max:
				{
					//read the max number of levels to be loaded
					tok = strtok(ptr," ");
					maxLevel = atoi(tok);
					toParse=dfg_count;
					break;
				}
			case dfg_count:
				{
					//read the number of nodes to be loaded
					tok = strtok(ptr," ");
					numberNodes = atoi(tok);
					toParse=op_delay;
					break;
				}
			case op_delay:
				{
					//read the number of nodes to be loaded
					tok = strtok(ptr," ");
					int addDelay = atoi(tok);
					tok = strtok(NULL," ");
					int subDelay = atoi(tok);
					tok = strtok(NULL," ");
					int mulDelay = atoi(tok);
					tok = strtok(NULL," ");
					int lshDelay = atoi(tok);
					tok = strtok(NULL," ");
					int regDelay = 1;
					if (tok) {
						regDelay = atoi(tok);
					}
					DfgNode::setOpDelays(addDelay,subDelay,mulDelay,lshDelay,regDelay);
					toParse=node_list;
					break;
				}
			case node_list:
				{
					nodeCount++;
					//read the variable type
					tok = strtok(ptr," ");
					nodeTypeStr = string(tok);
					//read variable name
					tok = strtok(NULL," ");
					nodeName = string(tok);
					//read unique ID
					tok = strtok(NULL," ");
					nodeID = string(tok);
					if(strcmp(nodeTypeStr.c_str(),"ADD") ==0) {
						nodeType=DfgOperator::ADD;
						toParse=left_kid;
					} else if(strcmp(nodeTypeStr.c_str(),"SUB") ==0) {
						nodeType=DfgOperator::SUB;
						toParse=left_kid;
					} else if(strcmp(nodeTypeStr.c_str(),"MUL") ==0) {
						nodeType=DfgOperator::MUL;
						toParse=left_kid;
					} else if(strcmp(nodeTypeStr.c_str(),"LSH") ==0) {
						nodeType=DfgOperator::LSH;
						toParse=left_kid;
					} else if(strcmp(nodeTypeStr.c_str(),"RSH") ==0) {
						nodeType=DfgOperator::RSH;
						toParse=left_kid;
					} else if(strcmp(nodeTypeStr.c_str(),"VAR") ==0) {
						//TODO: At the moment VARCONST is saved as VAR
						nodeType=DfgOperator::VAR;
						pNode = new DfgNode(this,nodeName.c_str());
						registerNode(pNode);
						uniqueTable.insert(pair<string,DfgNode*>(nodeID,pNode));
						if(nodeCount==numberNodes)
							toParse=po_list;
					} else if(strcmp(nodeTypeStr.c_str(),"CONST") ==0) {
						nodeType=DfgOperator::CONST;
						pair<bool,wedge> nodeValue=Util::atoi(nodeName.c_str());
						assert(nodeValue.first);
						pNode = new DfgNode(this,nodeValue.second);
						registerNode(pNode);
						uniqueTable.insert(pair<string,DfgNode*>(nodeID,pNode));
						if(nodeCount==numberNodes)
							toParse=po_list;
					} else if(strcmp(nodeTypeStr.c_str(),"REG") ==0) {
						nodeType=DfgOperator::REG;
						toParse=left_kid;
						string retimed = nodeName;
						assert(nodeName[nodeName.size()-1]==DfgNode::TOKEN_REG);
						retimed.erase(nodeName.size()-1);
						retimeValue=Util::atoi(retimed.c_str());
						assert(retimeValue.first);
					} else {
						throw(string("01005. UNKOWN DFG node type."));
					}
					break;
				}
			case left_kid:
				{
					//read kid number "i"
					tok = strtok(ptr," ");
					leftID = string(tok);
					uniqueIterator = uniqueTable.find(leftID);
					if(uniqueIterator != uniqueTable.end()) {
						pLeft = uniqueIterator->second;
					} else {
						string error = "01006. While processing node ";
						error += nodeName;
						error += " ";
						error += nodeID;
						error += "\n";
						error += "Its left child node ";
						error += leftID;
						error += " was not found";
						throw(error);
					}
					toParse=right_kid;
					break;
				}
			case right_kid:
				{
					tok = strtok(ptr," ");
					rightID = string(tok);
					uniqueIterator = uniqueTable.find(rightID);
					if(uniqueIterator != uniqueTable.end()) {
						pRight = uniqueIterator->second;
					} else {
						string error = "01007. While processing node ";
						error += nodeName;
						error += " ";
						error += nodeID;
						error += "\n";
						error += "Its right child node ";
						error += rightID;
						error += " was not found";
						throw(error);
					}
					if(nodeType==DfgOperator::REG) {
						assert(pLeft==pRight);
						pNode = pLeft->reg(retimeValue.second);
					} else {
						pNode = new DfgNode(this,nodeType,pLeft,pRight);
					}
					registerNode(pNode);
					uniqueTable.insert(pair<string,DfgNode*>(nodeID,pNode));
					if(nodeCount==numberNodes) {
						toParse=po_list;
					} else {
						toParse=node_list;
					}
					break;
				}
			case po_list:
				{
					/*read the output name*/
					tok = strtok(ptr, " ");
					poName = string(tok);
					/*read the ID*/
					tok = strtok(NULL, " ");
					poID = string(tok);
					uniqueIterator = uniqueTable.find(poID);
					if(uniqueIterator != uniqueTable.end()) {
						pNode = uniqueIterator->second;
						if(_mPos.find(poName) ==_mPos.end()) {
							_mPos.insert(pair<string,DfgNode*>(poName,pNode));
						} else {
							//if PO already exist load it as PO_read
							//and generate its difference PO_diff = PO - PO_read
							string poName2cmp = poName+"_read";
							DfgNode* pNode2cmp = pNode;
							_mPos.insert(pair<string,DfgNode*>(poName2cmp,pNode2cmp));
#if 0
							pNode = _mPos.find(poName)->second;
#else
							pNode = new DfgNode(this,poName.c_str());
							registerNode(pNode);
							pNode2cmp = new DfgNode(this,poName2cmp.c_str());
							registerNode(pNode2cmp);
#endif
							string poNameDiff = poName+"_diff";
							DfgNode* pNodeDiff = new DfgNode(this,DfgOperator::SUB,pNode,pNode2cmp);
							registerNode(pNodeDiff);
							_mPos.insert(pair<string,DfgNode*>(poNameDiff,pNodeDiff));
							//throw(string("01008. PO already exist"));
						}
					} else {
						throw(string("01009. While linking output node ")+ poName);
					}
					break;
				}
			default:
				throw(string("01010. While retrieving the DFG data structure"));
				break;
			}
		}
		updateDelayAndNumRefs();
	}

	void DfgMan::writeGappa(string filename) {
		ofstream ofile;
		if(filename.empty()) {
			//TODO probable leak as tempFileName allocates memory
			filename = Util::tempFileName(Environment::getStr("show_directory").c_str(), "saved_", "gappa");
		}
		if(!filename.empty())
			ofile.open(filename.c_str());
		if(!ofile.is_open()) {
			throw(string("01016. Cannot open temporary file for writing."));
			return;
		}
		ofile << "#######################################" << endl;
		ofile << "# File generated by TDS.              #" << endl;
		ofile << "# http://incascout.ecs.umass.edu/main #" << endl;
		ofile << "#######################################" << endl;
		ofile << "# To run gappa on this file, type:" << endl;
		ofile << "# gappa < \"filename\"" << endl;
		ofile << "##########################" << endl;
		ofile << "# Primary inputs' bitwidth and rounding definitions" << endl;
		vector <DfgNode* > vNodes;
		int maxLevel = collectDFS(vNodes);
		unsigned int sum_i = 0;
		unsigned int sub_i = 0;
		unsigned int mul_i = 0;
		unsigned int lsh_i = 0;
		unsigned int rsh_i = 0;
		//unsigned int current =0;
		map<DfgNode*, unsigned int> gappaTerm;
		for(unsigned int i = 0; i < vNodes.size(); i ++) {
			switch(vNodes[i]->getOp()) {
			case DfgOperator::VAR:
				{
					string piname = vNodes[i]->getName();
					ofile << piname << " = fixed<-";
					TedVar* pvar = vNodes[i]->getTedVarIfExist();
					if(!pvar)
						throw(string("01026. No associated TED variable with DFG node."));
					Bitwidth* pre = pvar->getBitwidth();
					if(pre) {
						ofile << pre->getSize();
					} else {
						ofile << "0";
					}
					ofile << ",dn>(M" << piname << ");" << endl;
					break;
				}
			case DfgOperator::ADD: gappaTerm.insert(pair<DfgNode*,unsigned int>(vNodes[i],++sum_i)); break;
			case DfgOperator::SUB: gappaTerm.insert(pair<DfgNode*,unsigned int>(vNodes[i],++sub_i)); break;
			case DfgOperator::MUL: gappaTerm.insert(pair<DfgNode*,unsigned int>(vNodes[i],++mul_i)); break;
			case DfgOperator::LSH: gappaTerm.insert(pair<DfgNode*,unsigned int>(vNodes[i],++lsh_i)); break;
			case DfgOperator::RSH: gappaTerm.insert(pair<DfgNode*,unsigned int>(vNodes[i],++rsh_i)); break;
			case DfgOperator::VARCONST:
			case DfgOperator::CONST: break;
			default: break;
			}
		}
		ofile <<"# DFG operations" << endl;
		map<DfgOperator::Type,string> opTable;
		opTable[DfgOperator::ADD] = "add";
		opTable[DfgOperator::SUB] = "sub";
		opTable[DfgOperator::MUL] = "mul";
		opTable[DfgOperator::DIV] = "div";
		opTable[DfgOperator::LSH] = "lsh";
		opTable[DfgOperator::RSH] = "rsh";
		//not the optimal implementation, but it gets the job done
		for(unsigned int i = 0; i < vNodes.size(); i ++) {
			if(vNodes[i]->isOp()) {
				//approximation
				ofile << opTable[vNodes[i]->getOp()] << gappaTerm[vNodes[i]] << " fixed<-";
				//ofile << opTable[vNodes[i]->getOp()] << vNodes[i]->_op->getID()<< " fixed<-";
				if(vNodes[i]->_op) {
					ofile << vNodes[i]->_op->getBitwidth()->getSize()<< "," << "dn" << ">= ";
				} else {
					ofile << "0" << "," << "dn" <<">= ";
				}
				GAPPA_COMPUTATION(getLeft,);
				ofile << vNodes[i]->getOpStr();
				GAPPA_COMPUTATION(getRight,);
				ofile << ";" << endl;
				//free error computation
				ofile << "M" << opTable[vNodes[i]->getOp()] << gappaTerm[vNodes[i]] << " = ";
				//ofile << "M" << opTable[vNodes[i]->getOp()] << vNodes[i]->_op->getID()<< " = ";
				GAPPA_COMPUTATION(getLeft,M);
				ofile << vNodes[i]->getOpStr();
				GAPPA_COMPUTATION(getRight,M);
				ofile << ";" << endl;
			}
		}
		ofile << endl;
		ofile << "{" << endl;
		ofile << "# Primary inputs' range" << endl;
		bool first_pi = true;
		for(unsigned int i = 0; i < vNodes.size(); i ++)if(vNodes[i]->isPI()) {
			if(!first_pi) {
				ofile << " /\\ ";
			} else {
				first_pi = false;
			}
			ofile << vNodes[i]->getName()<< " in ";
			TedVar* pvar = vNodes[i]->getTedVarIfExist();
			if(!pvar)
				throw(string("01027. No associated TED var with DFG node."));
			if(pvar->hasRange()) {
				ofile << pvar->getRange();
			} else {
				ofile << "[0" << ",";
				Bitwidth* pre = pvar->getBitwidth();
				if(pre) {
					ofile << pre->getMaxRange();
				} else {
					ofile << "1";
				}
				ofile << "]" << endl;
			}
		}
		ofile << "# Primary outputs' absolute error" << endl;
		ofile << "->" << endl;
		bool first_po = true;
		for(map<string, DfgNode*>::iterator p = _mPos.begin(); p != _mPos.end(); p++) {
			if(!first_po) {
				ofile << " /\\ ";
			} else {
				first_po = false;
			}
			ofile << "#output " << p->first << endl;
			ofile << "|" << opTable[p->second->getOp()] << gappaTerm[p->second] << " - M";
			ofile << opTable[p->second->getOp()] << gappaTerm[p->second] << "| in ?";
			//ofile << "|" << opTable[p->second->getOp()] << p->second->_op->getID()<< " - M";
			//ofile << opTable[p->second->getOp()] << p->second->_op->getID()<< "| in ?";
		}
		ofile << endl;
		ofile << "}" << endl;
		ofile << "##########################" << endl;
		ofile << "#EOF" << endl;
		ofile.close();
	}
}
